<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CHECK__777__</title>
  <style>
    :root{
      --bg:#0b1220; --card:#0f1b33; --card2:#0c1730; --txt:#e7eefc; --muted:#a9b7d6;
      --line:#1e2b4e; --accent:#7aa7ff; --ok:#4ade80; --warn:#ffd166; --danger:#ff6b6b;
      --shadow: 0 18px 50px rgba(0,0,0,.35);
      --radius: 16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    *{box-sizing:border-box}
    body{margin:0; font-family:var(--font); background:radial-gradient(1200px 900px at 10% 10%, #101e3d 0%, var(--bg) 55%) fixed; color:var(--txt);}
    a{color:var(--accent); text-decoration:none}
    .wrap{max-width:1200px; margin:0 auto; padding:18px}
    .topbar{display:flex; align-items:center; justify-content:space-between; gap:12px; padding:14px 16px; background:rgba(15,27,51,.75); border:1px solid var(--line); border-radius:var(--radius); box-shadow:var(--shadow); backdrop-filter: blur(10px);}
    .brand{display:flex; flex-direction:column; gap:2px}
    .brand .title{font-weight:800; letter-spacing:.3px}
    .brand .sub{font-size:12px; color:var(--muted)}
    .row{display:grid; grid-template-columns: 320px 1fr; gap:16px; margin-top:16px}
    @media (max-width:980px){ .row{grid-template-columns:1fr} }
    .card{background:rgba(15,27,51,.78); border:1px solid var(--line); border-radius:var(--radius); box-shadow:var(--shadow); overflow:hidden;}
    .card .hd{padding:14px 16px; border-bottom:1px solid var(--line); display:flex; align-items:center; justify-content:space-between; gap:10px}
    .card .hd h3{margin:0; font-size:14px; letter-spacing:.2px}
    .card .bd{padding:14px 16px}
    .pill{font-size:12px; padding:4px 10px; border-radius:999px; background:rgba(122,167,255,.12); border:1px solid rgba(122,167,255,.35); color:var(--txt)}
    .pill.ok{background:rgba(74,222,128,.12); border-color:rgba(74,222,128,.35)}
    .pill.warn{background:rgba(255,209,102,.12); border-color:rgba(255,209,102,.35)}
    .pill.danger{background:rgba(255,107,107,.12); border-color:rgba(255,107,107,.35)}
    .btn{appearance:none; border:1px solid var(--line); background:rgba(12,23,48,.9); color:var(--txt); padding:10px 12px; border-radius:12px; cursor:pointer; font-weight:600}
    .btn:hover{border-color:rgba(122,167,255,.55)}
    .btn.primary{background:rgba(122,167,255,.18); border-color:rgba(122,167,255,.55)}
    .btn.danger{background:rgba(255,107,107,.12); border-color:rgba(255,107,107,.45)}
    .btn:disabled{opacity:.55; cursor:not-allowed}
    .grid{display:grid; gap:12px}
    .nav{display:grid; gap:8px}
    .nav button{width:100%; text-align:left}
    .nav .active{border-color:rgba(122,167,255,.8); background:rgba(122,167,255,.18)}
    .kv{display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center}
    .muted{color:var(--muted); font-size:12px}
    label{display:block; font-size:12px; color:var(--muted); margin-bottom:6px}
    input, select, textarea{
      width:100%; padding:10px 12px; border-radius:12px; border:1px solid var(--line);
      background:rgba(12,23,48,.9); color:var(--txt); outline:none;
    }
    textarea{min-height:110px; font-family:var(--mono); font-size:12px}
    .hint{font-size:12px; color:var(--muted); margin-top:6px}
    .split{display:grid; grid-template-columns:1fr 1fr; gap:10px}
    @media (max-width:520px){ .split{grid-template-columns:1fr} }
    .toast{position:fixed; right:18px; bottom:18px; width:min(420px, calc(100vw - 36px)); display:grid; gap:10px; z-index:99}
    .titem{padding:12px 12px; border-radius:14px; border:1px solid var(--line); box-shadow:var(--shadow); background:rgba(12,23,48,.95)}
    .titem .t{font-weight:800; font-size:13px; margin-bottom:4px}
    .titem.ok{border-color:rgba(74,222,128,.4)}
    .titem.warn{border-color:rgba(255,209,102,.4)}
    .titem.danger{border-color:rgba(255,107,107,.4)}
    .titem pre{margin:8px 0 0; white-space:pre-wrap; word-break:break-word; font-family:var(--mono); font-size:12px; color:#dbe7ff}
    table{width:100%; border-collapse:collapse; font-size:12px}
    th,td{padding:10px 8px; border-bottom:1px solid rgba(30,43,78,.7); vertical-align:top}
    th{color:var(--muted); font-weight:700; text-align:left}
    .small{font-size:12px}
    .mono{font-family:var(--mono)}
    .right{display:flex; gap:8px; align-items:center}
    .sep{height:1px; background:rgba(30,43,78,.7); margin:10px 0}
    .badge{font-size:11px; padding:3px 8px; border-radius:999px; border:1px solid rgba(169,183,214,.35); color:var(--muted)}
    .dangerText{color:var(--danger)}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="title">Just Presence — Frontend</div>
        <div class="sub">Auto-mapped from Swagger/OpenAPI. Base: <span class="mono" id="baseTxt"></span></div>
      </div>
      <div class="right">
        <span id="authPill" class="pill warn">Not Authenticated</span>
        <button class="btn" id="btnReloadSpec">Reload API Spec</button>
        <button class="btn danger" id="btnLogout" disabled>Logout</button>
      </div>
    </div>

    <div class="row">
      <div class="card">
        <div class="hd"><h3>Menu</h3><span class="badge" id="specBadge">spec: -</span></div>
        <div class="bd grid">
          <div class="nav" id="nav"></div>
          <div class="sep"></div>
          <div class="grid">
            <div class="kv">
              <div>
                <div class="small"><b>Swagger UI</b></div>
                <div class="muted mono" id="swaggerUrl"></div>
              </div>
              <button class="btn" id="btnOpenSwagger">Open</button>
            </div>
            <div class="kv">
              <div>
                <div class="small"><b>Token</b></div>
                <div class="muted">Stored in localStorage</div>
              </div>
              <button class="btn" id="btnCopyToken">Copy</button>
            </div>
            <div class="kv">
              <div>
                <div class="small"><b>User</b></div>
                <div class="muted mono" id="userTxt">-</div>
              </div>
              <button class="btn" id="btnClearUser">Clear</button>
            </div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="hd">
          <h3 id="pageTitle">Loading…</h3>
          <span class="muted" id="pageHint"></span>
        </div>
        <div class="bd" id="page"></div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

<script>
/* =========================
   CONFIG
   ========================= */
const CONFIG = {
  baseUrl: "https://just-presence-production-79e0.up.railway.app",
  swaggerUi: "https://just-presence-production-79e0.up.railway.app/swagger-ui/index.html#/",
  openApiCandidates: [
    "/v3/api-docs",
    "/v3/api-docs?group=default",
    "/api-docs",
    "/swagger/v1/swagger.json",
    "/openapi.json"
  ],
  validation: {
    password: { min: 8, max: 72 },
    email: { pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/i },
    phone: { pattern: /^[0-9+\-\s()]{6,}$/ }
  }
};

/* =========================
   STATE
   ========================= */
const store = {
  token: localStorage.getItem("jp_token") || "",
  user: safeJson(localStorage.getItem("jp_user")) || null,
  spec: null,
  specUrl: null,
  ops: {
    login: null,
    register: null,
    me: null,

    // optional "get user by id" (fixes User not found with id: 7 when /me not used)
    userById: null,

    createCourse: null,
    listCourses: null,
    updateCourse: null,

    createCanteenItem: null,
    listCanteenItems: null,
    updateCanteenItem: null,

    createStudent: null,
    listStudents: null,
    updateStudent: null,

    createTeacher: null,
    listTeachers: null,
    updateTeacher: null
  }
};

const el = (id)=>document.getElementById(id);

/* =========================
   UI HELPERS
   ========================= */
function toast(kind, title, detail){
  const host = el("toast");
  const item = document.createElement("div");
  item.className = `titem ${kind||""}`;
  item.innerHTML = `
    <div class="t">${escapeHtml(title||"")}</div>
    ${detail ? `<pre>${escapeHtml(String(detail))}</pre>` : ``}
  `;
  host.appendChild(item);
  setTimeout(()=>{ item.style.opacity="0"; item.style.transform="translateY(8px)"; }, 4200);
  setTimeout(()=>{ item.remove(); }, 4800);
}
function setBusy(isBusy){
  document.querySelectorAll("button, input, select, textarea").forEach(n=>{
    if(n.id==="btnOpenSwagger") return;
    if(n.id==="btnCopyToken") return;
    if(n.id==="btnClearUser") return;
    n.disabled = !!isBusy && (n.tagName==="BUTTON" ? true : n.disabled);
  });
}
function escapeHtml(s){
  return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}
function safeJson(s){ try{ return JSON.parse(s); }catch{ return null; } }

/* =========================
   JWT + USER NORMALIZATION (FIX USERID)
   ========================= */
function parseJwt(token){
  try{
    const base64Url = token.split(".")[1];
    const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
    const json = decodeURIComponent(atob(base64).split("").map(c =>
      "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2)
    ).join(""));
    return JSON.parse(json);
  }catch{
    return null;
  }
}

function normalizeUser(me, token){
  const jwt = token ? parseJwt(token) : null;

  const id =
    me?.id ??
    me?.userId ??
    me?.uid ??
    jwt?.id ??
    jwt?.userId ??
    jwt?.uid ??
    jwt?.sub ??
    null;

  const email =
    me?.email ??
    me?.username ??
    jwt?.email ??
    jwt?.preferred_username ??
    jwt?.upn ??
    null;

  const role =
    me?.role ??
    me?.userRole ??
    me?.type ??
    jwt?.role ??
    (Array.isArray(jwt?.roles) ? jwt.roles[0] : jwt?.roles) ??
    (Array.isArray(jwt?.authorities) ? jwt.authorities[0] : jwt?.authorities) ??
    null;

  return { ...(me||{}), id, email, role, _jwt: jwt };
}

function getUserId(){
  return store.user?.id ?? store.user?.userId ?? store.user?._jwt?.sub ?? null;
}

function persistSession(){
  localStorage.setItem("jp_token", store.token || "");
  localStorage.setItem("jp_user", JSON.stringify(store.user || null));
  setAuthUI();
}

/* =========================
   API CLIENT
   ========================= */
async function apiFetch(path, { method="GET", headers={}, body=null, query=null } = {}){
  const url = new URL(CONFIG.baseUrl + path);
  if(query){
    Object.entries(query).forEach(([k,v])=>{
      if(v===undefined || v===null || v==="") return;
      url.searchParams.set(k, String(v));
    });
  }

  const h = { "Accept":"application/json", ...headers };
  if(store.token) h["Authorization"] = `Bearer ${store.token}`;

  let payload = body;
  if(body && typeof body === "object" && !(body instanceof FormData)){
    h["Content-Type"] = "application/json";
    payload = JSON.stringify(body);
  }

  const res = await fetch(url.toString(), { method, headers: h, body: payload });
  const text = await res.text();
  let data = null;
  try{ data = text ? JSON.parse(text) : null; }catch{ data = text; }

  if(!res.ok){
    const msg = (data && (data.message || data.error || data.detail)) ? (data.message || data.error || data.detail) : res.statusText;
    const err = new Error(msg || `HTTP ${res.status}`);
    err.status = res.status;
    err.data = data;
    throw err;
  }
  return data;
}

/* =========================
   OPENAPI LOADING + MAPPING
   ========================= */
async function loadSpec(){
  store.spec = null;
  store.specUrl = null;
  el("specBadge").textContent = "spec: loading…";

  let lastErr = null;
  for(const p of CONFIG.openApiCandidates){
    try{
      const data = await apiFetch(p, { method:"GET", headers:{}, body:null });
      if(data && (data.openapi || data.swagger) && data.paths){
        store.spec = data;
        store.specUrl = CONFIG.baseUrl + p;
        el("specBadge").textContent = "spec: loaded";
        deriveOps();
        return;
      }
    }catch(e){
      lastErr = e;
    }
  }

  el("specBadge").textContent = "spec: not found";
  toast("danger","OpenAPI spec not reachable",
        "Backend must expose JSON (ex: /v3/api-docs). Swagger UI alone is not enough for auto-linking.\n\nLast error:\n" + (lastErr ? (lastErr.message || String(lastErr)) : "unknown"));
}

function deriveOps(){
  Object.keys(store.ops).forEach(k=>store.ops[k]=null);

  const spec = store.spec;
  if(!spec || !spec.paths) return;

  const candidates = [];
  for(const [path, methods] of Object.entries(spec.paths)){
    for(const [m, op] of Object.entries(methods)){
      if(!op || typeof op !== "object") continue;
      const method = m.toUpperCase();
      if(!["GET","POST","PUT","PATCH","DELETE"].includes(method)) continue;
      candidates.push({ path, method, op });
    }
  }

  const pick = (preds) => {
    for(const pred of preds){
      const found = candidates.find(pred);
      if(found) return found;
    }
    return null;
  };

  const has = (s, ...parts) => {
    const t = String(s||"").toLowerCase();
    return parts.every(p => t.includes(String(p).toLowerCase()));
  };

  // Auth
  store.ops.login = pick([
    x => x.method==="POST" && (has(x.path,"/auth","login") || has(x.op.operationId,"login")),
    x => x.method==="POST" && (has(x.op.summary,"login") || has(x.op.description,"login"))
  ]);

  store.ops.register = pick([
    x => x.method==="POST" && (has(x.path,"/auth","register") || has(x.op.operationId,"register") || has(x.path,"/register")),
    x => x.method==="POST" && (has(x.op.summary,"register") || has(x.op.description,"register") || (has(x.op.summary,"sign") && has(x.op.summary,"up")))
  ]);

  store.ops.me = pick([
    x => x.method==="GET" && (has(x.path,"/auth","me") || has(x.op.operationId,"me") || has(x.path,"/me")),
    x => x.method==="GET" && (has(x.op.summary,"profile") || has(x.op.summary,"current user"))
  ]);

  // user by id (GET /users/{id})
  store.ops.userById = pick([
    x => x.method==="GET" && (has(x.path,"/users/{") || has(x.path,"/user/{")),
    x => x.method==="GET" && (has(x.op.operationId,"get") && (has(x.op.operationId,"user") || has(x.op.summary,"user"))) && has(x.path,"/{")
  ]);

  // CRUD helper
  const crud = (entity) => {
    const e = entity.toLowerCase();
    const create = pick([
      x => x.method==="POST" && (has(x.path, `/${e}`) || has(x.path, `/${e}s`)) && !has(x.path,"/search"),
      x => x.method==="POST" && (has(x.op.operationId, "create", e) || has(x.op.operationId, "add", e)),
      x => x.method==="POST" && (has(x.op.summary, "create", e) || has(x.op.summary, "add", e))
    ]);
    const list = pick([
      x => x.method==="GET" && (has(x.path, `/${e}`) || has(x.path, `/${e}s`)) && !has(x.path,"/{") && !has(x.path,"/search"),
      x => x.method==="GET" && (has(x.op.operationId, "get", e) || has(x.op.operationId, "list", e)),
      x => x.method==="GET" && (has(x.op.summary, "list", e) || has(x.op.summary, "get", e)) && !has(x.path,"/{")
    ]);
    const update = pick([
      x => (x.method==="PUT" || x.method==="PATCH") && (has(x.path, `/${e}`) || has(x.path, `/${e}s`)) && has(x.path,"/{"),
      x => (x.method==="PUT" || x.method==="PATCH") && (has(x.op.operationId, "update", e) || has(x.op.summary, "update", e)),
    ]);
    return { create, list, update };
  };

  const course = crud("course");
  store.ops.createCourse = course.create;
  store.ops.listCourses = course.list;
  store.ops.updateCourse = course.update;

  const canteen = crud("canteen");
  store.ops.createCanteenItem = pick([
    x => x.method==="POST" && (has(x.path,"canteen") && (has(x.path,"item") || has(x.path,"items"))),
    x => canteen.create
  ]);
  store.ops.listCanteenItems = pick([
    x => x.method==="GET" && (has(x.path,"canteen") && (has(x.path,"item") || has(x.path,"items"))) && !has(x.path,"/{"),
    x => canteen.list
  ]);
  store.ops.updateCanteenItem = pick([
    x => (x.method==="PUT" || x.method==="PATCH") && (has(x.path,"canteen") && (has(x.path,"item") || has(x.path,"items"))) && has(x.path,"/{"),
    x => canteen.update
  ]);

  const student = crud("student");
  store.ops.createStudent = student.create;
  store.ops.listStudents = student.list;
  store.ops.updateStudent = student.update;

  const teacher = crud("teacher");
  store.ops.createTeacher = teacher.create;
  store.ops.listTeachers = teacher.list;
  store.ops.updateTeacher = teacher.update;
}

function opToText(op){
  if(!op) return "-";
  return `${op.method} ${op.path}`;
}

function getRequestSchema(op){
  if(!op || !op.op) return null;
  const rb = op.op.requestBody;
  if(!rb || !rb.content) return null;

  const json = rb.content["application/json"] || rb.content["application/*+json"];
  if(json && json.schema) return derefSchema(json.schema);

  const first = Object.values(rb.content)[0];
  if(first && first.schema) return derefSchema(first.schema);

  return null;
}

function derefSchema(schema){
  const spec = store.spec;
  if(!schema || !spec) return schema;

  if(schema.$ref){
    const ref = schema.$ref;
    const key = ref.split("/").pop();
    const comps = (spec.components && spec.components.schemas) ? spec.components.schemas : {};
    return comps[key] ? comps[key] : schema;
  }
  return schema;
}

/* =========================
   FORM GENERATION + VALIDATION
   ========================= */
function buildFormFromSchema(schema, { mode="create" } = {}){
  const wrap = document.createElement("div");
  wrap.className = "grid";

  if(!schema){
    wrap.innerHTML = `
      <div class="muted">
        No request schema found in OpenAPI for this endpoint.
        Use the JSON editor below and send raw payload.
      </div>
      <label>Raw JSON Body</label>
      <textarea id="rawJson" placeholder='{"example":"value"}'></textarea>
    `;
    return {
      el: wrap,
      getValue: () => {
        const t = wrap.querySelector("#rawJson").value.trim();
        if(!t) return {};
        return JSON.parse(t);
      },
      validate: () => ({ ok:true })
    };
  }

  const props = schema.properties || {};
  const required = new Set(schema.required || []);
  const fields = [];

  for(const [name, def] of Object.entries(props)){
    if(mode === "create" && name.toLowerCase() === "id") continue;

    const f = document.createElement("div");
    const id = `f_${name}_${Math.random().toString(16).slice(2)}`;

    const labelTxt = `${name}${required.has(name) ? " *" : ""}`;
    const type = (def.format==="email" || name.toLowerCase().includes("email")) ? "email"
               : (def.format==="password" || name.toLowerCase().includes("password")) ? "password"
               : (def.type==="integer" || def.type==="number") ? "number"
               : "text";

    let inputEl;

    if(def.enum && Array.isArray(def.enum)){
      inputEl = document.createElement("select");
      inputEl.id = id;
      inputEl.innerHTML = `<option value="">Select…</option>` + def.enum.map(v=>`<option value="${escapeHtml(String(v))}">${escapeHtml(String(v))}</option>`).join("");
    }else if(def.type==="boolean"){
      inputEl = document.createElement("select");
      inputEl.id = id;
      inputEl.innerHTML = `<option value="">Select…</option><option value="true">true</option><option value="false">false</option>`;
    }else if(def.type==="object" || def.type==="array"){
      inputEl = document.createElement("textarea");
      inputEl.id = id;
      inputEl.placeholder = def.type==="array" ? "[]" : "{}";
      inputEl.className = "mono";
    }else{
      inputEl = document.createElement("input");
      inputEl.id = id;
      inputEl.type = type;
      if(type==="password"){
        inputEl.autocomplete = mode==="create" ? "new-password" : "current-password";
      }
    }

    const desc = def.description || def.title || "";
    f.innerHTML = `<label for="${id}">${escapeHtml(labelTxt)}</label>`;
    f.appendChild(inputEl);
    if(desc) {
      const d = document.createElement("div");
      d.className="hint";
      d.textContent = desc;
      f.appendChild(d);
    }

    fields.push({ name, def, required: required.has(name), inputEl });
    wrap.appendChild(f);
  }

  const validate = () => {
    const errors = [];

    for(const fld of fields){
      const n = fld.name;
      const v = getFieldValue(fld);

      if(fld.required && (v===undefined || v===null || v==="" )){
        errors.push(`${n} is required`);
        continue;
      }
      if(v===undefined || v===null || v==="") continue;

      const lname = n.toLowerCase();
      if(lname.includes("email") || fld.def.format==="email"){
        if(!CONFIG.validation.email.pattern.test(String(v))) errors.push(`Invalid email: ${n}`);
      }
      if(lname.includes("password") || fld.def.format==="password"){
        const s = String(v);
        if(s.length < CONFIG.validation.password.min) errors.push(`Password too short (${CONFIG.validation.password.min}+): ${n}`);
        if(s.length > CONFIG.validation.password.max) errors.push(`Password too long (${CONFIG.validation.password.max} max): ${n}`);
      }
      if(lname.includes("phone") || lname.includes("mobile")){
        if(!CONFIG.validation.phone.pattern.test(String(v))) errors.push(`Invalid phone: ${n}`);
      }
    }

    return errors.length ? { ok:false, errors } : { ok:true };
  };

  const getValue = () => {
    const obj = {};
    for(const fld of fields){
      const v = getFieldValue(fld);
      if(v===undefined) continue;
      if(v==="" && !fld.required) continue;
      obj[fld.name] = v;
    }
    return obj;
  };

  return { el: wrap, getValue, validate };
}

function getFieldValue(fld){
  const elx = fld.inputEl;
  const def = fld.def;

  if(elx.tagName === "TEXTAREA"){
    const t = elx.value.trim();
    if(!t) return fld.required ? "" : undefined;
    try { return JSON.parse(t); } catch { return t; }
  }
  if(elx.tagName === "SELECT"){
    const v = elx.value;
    if(v==="") return fld.required ? "" : undefined;
    if(def.type==="boolean") return v === "true";
    return v;
  }
  const raw = elx.value;
  if(raw === "") return fld.required ? "" : undefined;
  if(def.type==="integer") return parseInt(raw,10);
  if(def.type==="number") return Number(raw);
  return raw;
}

/* =========================
   WHOAMI (FIX)
   ========================= */
async function refreshMeSmart(){
  if(!store.token) return null;

  // 1) prefer /auth/me if present
  if(store.ops.me){
    try{
      const me = await apiFetch(store.ops.me.path, { method: store.ops.me.method });
      store.user = normalizeUser(me, store.token);
      persistSession();
      return store.user;
    }catch(e){
      // continue fallback
    }
  }

  // 2) fallback to JWT only (still gives id/sub if exists)
  store.user = normalizeUser(store.user || {}, store.token);
  persistSession();

  // 3) if API doesn't have /me but has /users/{id}, call it using id from JWT
  const uid = getUserId();
  if(uid && store.ops.userById){
    try{
      const path = store.ops.userById.path.replace(/\{[^}]+\}/, encodeURIComponent(String(uid)));
      const u = await apiFetch(path, { method: store.ops.userById.method });
      store.user = normalizeUser(u, store.token);
      persistSession();
      return store.user;
    }catch{
      // ignore
    }
  }

  return store.user;
}

/* =========================
   PAGES
   ========================= */
const pages = [
  { key:"login", title:"Login", hint:"Authenticate and store JWT", render: renderLogin },
  { key:"register", title:"Register", hint:"Create an account (if backend supports it)", render: renderRegister },
  { key:"courses", title:"Courses", hint:"Add / list / update courses", render: ()=>renderCrud("Course", store.ops.createCourse, store.ops.listCourses, store.ops.updateCourse) },
  { key:"canteen", title:"Canteen Items", hint:"Add / list / update canteen items", render: ()=>renderCrud("Canteen Item", store.ops.createCanteenItem, store.ops.listCanteenItems, store.ops.updateCanteenItem) },
  { key:"students", title:"Students (Admin)", hint:"Add / list / update students", render: ()=>renderCrud("Student", store.ops.createStudent, store.ops.listStudents, store.ops.updateStudent, { adminOnly:true }) },
  { key:"teachers", title:"Teachers (Admin)", hint:"Add / list / update teachers", render: ()=>renderCrud("Teacher", store.ops.createTeacher, store.ops.listTeachers, store.ops.updateTeacher, { adminOnly:true }) },
  { key:"debug", title:"Debug", hint:"See detected endpoints + WhoAmI + Raw", render: renderDebug }
];

let currentPage = "login";

function renderNav(){
  const nav = el("nav");
  nav.innerHTML = "";
  pages.forEach(p=>{
    const b = document.createElement("button");
    b.className = "btn " + (p.key===currentPage ? "active" : "");
    b.textContent = p.title;
    b.onclick = ()=>goto(p.key);
    nav.appendChild(b);
  });
}

function goto(key){
  currentPage = key;
  renderNav();
  const p = pages.find(x=>x.key===key);
  el("pageTitle").textContent = p ? p.title : key;
  el("pageHint").textContent = p ? p.hint : "";
  const host = el("page");
  host.innerHTML = "";
  (p ? p.render : renderDebug)();
}

function setAuthUI(){
  el("baseTxt").textContent = CONFIG.baseUrl;
  el("swaggerUrl").textContent = CONFIG.swaggerUi;

  const pill = el("authPill");
  const btnLogout = el("btnLogout");
  const userTxt = el("userTxt");

  if(store.user){
    const uid = store.user.id ?? store.user.userId ?? null;
    const em = store.user.email ?? store.user.username ?? null;
    userTxt.textContent = `${uid ? "id="+uid : "id=-"}${em ? " | "+em : ""}`;
  }else{
    userTxt.textContent = "-";
  }

  if(store.token){
    pill.className = "pill ok";
    const uid = getUserId();
    pill.textContent = uid ? `Authenticated (id: ${uid})` : "Authenticated";
    btnLogout.disabled = false;
  }else{
    pill.className = "pill warn";
    pill.textContent = "Not Authenticated";
    btnLogout.disabled = true;
  }
}

function renderLogin(){
  const host = el("page");

  const op = store.ops.login;
  const schema = getRequestSchema(op);

  const form = buildFormFromSchema(schema, { mode:"login" });
  const box = document.createElement("div");
  box.className = "grid";

  const info = document.createElement("div");
  info.className = "muted";
  info.innerHTML = `
    Detected login endpoint: <span class="mono">${escapeHtml(opToText(op))}</span>
    <div class="hint">بعد اللوجين هيتعمل WhoAmI تلقائي عشان يظبط الـuserId.</div>
  `;
  box.appendChild(info);
  box.appendChild(form.el);

  const actions = document.createElement("div");
  actions.className = "split";
  actions.innerHTML = `
    <button class="btn primary" id="doLogin">Login</button>
    <button class="btn" id="goRegister">Go to Register</button>
  `;
  box.appendChild(actions);

  host.appendChild(box);

  host.querySelector("#goRegister").onclick = ()=>goto("register");
  host.querySelector("#doLogin").onclick = async ()=>{
    try{
      if(!op) throw new Error("Login operation not found in spec.");
      const v = form.validate();
      if(!v.ok) throw new Error(v.errors.join("\n"));

      const payload = form.getValue();
      const data = await apiFetch(op.path, { method: op.method, body: payload });

      const token = (data && (data.token || data.accessToken || data.jwt || data.id_token))
        ? (data.token || data.accessToken || data.jwt || data.id_token)
        : (data && data.data && (data.data.token || data.data.accessToken || data.data.jwt))
          ? (data.data.token || data.data.accessToken || data.data.jwt)
          : null;

      if(!token) throw new Error("Login succeeded but token not found in response. Check response in Debug.");

      store.token = token;
      localStorage.setItem("jp_token", store.token);

      // FIX: Always normalize userId from /me or JWT
      await refreshMeSmart();

      toast("ok","Login success", "Token saved + userId normalized.");
      setAuthUI();
      goto("courses");
    }catch(e){
      toast("danger","Login failed", `${e.message}\n\n${e.data ? JSON.stringify(e.data,null,2) : ""}`.trim());
    }
  };
}

function renderRegister(){
  const host = el("page");

  const op = store.ops.register;
  const schema = getRequestSchema(op);
  const form = buildFormFromSchema(schema, { mode:"register" });

  const box = document.createElement("div");
  box.className = "grid";

  const info = document.createElement("div");
  info.className = "muted";
  info.innerHTML = `
    Detected register endpoint: <span class="mono">${escapeHtml(opToText(op))}</span>
    <div class="hint">Email/password validation enforced client-side.</div>
  `;
  box.appendChild(info);
  box.appendChild(form.el);

  const actions = document.createElement("div");
  actions.className = "split";
  actions.innerHTML = `
    <button class="btn primary" id="doRegister">Register</button>
    <button class="btn" id="goLogin">Go to Login</button>
  `;
  box.appendChild(actions);

  host.appendChild(box);

  host.querySelector("#goLogin").onclick = ()=>goto("login");
  host.querySelector("#doRegister").onclick = async ()=>{
    try{
      if(!op) throw new Error("Register operation not found in spec.");
      const v = form.validate();
      if(!v.ok) throw new Error(v.errors.join("\n"));
      const payload = form.getValue();
      const data = await apiFetch(op.path, { method: op.method, body: payload });
      toast("ok","Register success", JSON.stringify(data,null,2));
      goto("login");
    }catch(e){
      toast("danger","Register failed", `${e.message}\n\n${e.data ? JSON.stringify(e.data,null,2) : ""}`.trim());
    }
  };
}

function renderCrud(label, opCreate, opList, opUpdate, { adminOnly=false } = {}){
  const host = el("page");
  const box = document.createElement("div");
  box.className = "grid";

  const gate = document.createElement("div");
  gate.className = "muted";
  gate.innerHTML = `
    <div><b>${escapeHtml(label)}</b></div>
    <div class="hint">
      Create: <span class="mono">${escapeHtml(opToText(opCreate))}</span><br/>
      List: <span class="mono">${escapeHtml(opToText(opList))}</span><br/>
      Update: <span class="mono">${escapeHtml(opToText(opUpdate))}</span>
    </div>
  `;
  box.appendChild(gate);

  const authNote = document.createElement("div");
  authNote.className = "muted";
  authNote.innerHTML = adminOnly
    ? `Admin-only screen. Backend enforces role; frontend blocks if not logged in.`
    : `Token is required for protected endpoints.`;
  box.appendChild(authNote);

  const createCard = document.createElement("div");
  createCard.className = "card";
  createCard.innerHTML = `<div class="hd"><h3>Create ${escapeHtml(label)}</h3><span class="muted">POST</span></div><div class="bd" id="createBox"></div>`;
  box.appendChild(createCard);

  const listCard = document.createElement("div");
  listCard.className = "card";
  listCard.innerHTML = `<div class="hd"><h3>${escapeHtml(label)} List</h3><div class="right"><button class="btn" id="btnRefresh">Refresh</button></div></div><div class="bd" id="listBox"></div>`;
  box.appendChild(listCard);

  host.appendChild(box);

  const createHost = createCard.querySelector("#createBox");
  if(!opCreate){
    createHost.innerHTML = `<div class="muted">Create endpoint not detected. Use Debug.</div>`;
  }else{
    const schema = getRequestSchema(opCreate);
    const form = buildFormFromSchema(schema, { mode:"create" });
    createHost.appendChild(form.el);

    const btn = document.createElement("button");
    btn.className = "btn primary";
    btn.textContent = `Create ${label}`;
    btn.onclick = async ()=>{
      try{
        if(!store.token) throw new Error("Not authenticated.");
        const v = form.validate();
        if(!v.ok) throw new Error(v.errors.join("\n"));
        const payload = form.getValue();
        const data = await apiFetch(opCreate.path, { method: opCreate.method, body: payload });
        toast("ok", `${label} created`, JSON.stringify(data,null,2));
        await refreshList();
      }catch(e){
        toast("danger", `Create ${label} failed`, `${e.message}\n\n${e.data ? JSON.stringify(e.data,null,2) : ""}`.trim());
      }
    };
    createHost.appendChild(document.createElement("div")).style.height="8px";
    createHost.appendChild(btn);
  }

  const listHost = listCard.querySelector("#listBox");
  listCard.querySelector("#btnRefresh").onclick = refreshList;

  async function refreshList(){
    try{
      if(!opList){
        listHost.innerHTML = `<div class="muted">List endpoint not detected. Use Debug.</div>`;
        return;
      }
      if(!store.token) throw new Error("Not authenticated.");

      const data = await apiFetch(opList.path, { method: opList.method });
      const rows = normalizeList(data);

      listHost.innerHTML = "";
      if(!rows.length){
        listHost.innerHTML = `<div class="muted">No items returned.</div><div class="hint mono">${escapeHtml(JSON.stringify(data,null,2))}</div>`;
        return;
      }

      const table = document.createElement("table");
      const keys = collectKeys(rows, 8);

      table.innerHTML = `
        <thead>
          <tr>
            ${keys.map(k=>`<th>${escapeHtml(k)}</th>`).join("")}
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          ${rows.map((r,i)=>`
            <tr>
              ${keys.map(k=>`<td class="mono">${escapeHtml(toCell(r[k]))}</td>`).join("")}
              <td>
                <button class="btn" data-i="${i}" data-act="edit">Edit</button>
              </td>
            </tr>
          `).join("")}
        </tbody>
      `;
      listHost.appendChild(table);

      table.querySelectorAll("button[data-act='edit']").forEach(b=>{
        b.onclick = ()=>openEdit(rows[Number(b.dataset.i)]);
      });

    }catch(e){
      listHost.innerHTML = `<div class="muted">Failed to load list.</div>`;
      toast("danger", "List failed", `${e.message}\n\n${e.data ? JSON.stringify(e.data,null,2) : ""}`.trim());
    }
  }

  function normalizeList(data){
    if(!data) return [];
    if(Array.isArray(data)) return data;
    if(Array.isArray(data.items)) return data.items;
    if(Array.isArray(data.content)) return data.content;
    if(Array.isArray(data.data)) return data.data;
    for(const v of Object.values(data)){
      if(Array.isArray(v)) return v;
    }
    return [];
  }

  function collectKeys(rows, limit){
    const freq = new Map();
    rows.forEach(r=>{
      if(!r || typeof r !== "object") return;
      Object.keys(r).forEach(k=> freq.set(k, (freq.get(k)||0)+1));
    });
    return [...freq.entries()].sort((a,b)=>b[1]-a[1]).slice(0,limit).map(x=>x[0]);
  }

  function toCell(v){
    if(v===null || v===undefined) return "";
    if(typeof v === "object") return JSON.stringify(v);
    return String(v);
  }

  function pickId(obj){
    if(!obj || typeof obj!=="object") return null;
    return obj.id ?? obj._id ?? obj.userId ?? obj.studentId ?? obj.teacherId ?? obj.courseId ?? obj.itemId ?? null;
  }

  function openEdit(row){
    if(!opUpdate){
      toast("warn","Update not available","Update endpoint not detected. Use Debug.");
      return;
    }
    const id = pickId(row);
    if(id===null || id===undefined || id===""){
      toast("warn","Cannot edit","No id field detected in list item.");
      return;
    }

    const modal = document.createElement("div");
    modal.style.position="fixed";
    modal.style.inset="0";
    modal.style.background="rgba(0,0,0,.55)";
    modal.style.display="grid";
    modal.style.placeItems="center";
    modal.style.padding="18px";
    modal.style.zIndex="999";

    const panel = document.createElement("div");
    panel.className="card";
    panel.style.width="min(980px, 100%)";

    const schema = getRequestSchema(opUpdate);
    const form = buildFormFromSchema(schema, { mode:"update" });
    prefill(form.el, row);

    panel.innerHTML = `
      <div class="hd">
        <h3>Edit ${escapeHtml(label)} <span class="muted mono">id=${escapeHtml(String(id))}</span></h3>
        <div class="right">
          <button class="btn" id="close">Close</button>
        </div>
      </div>
      <div class="bd" id="body"></div>
    `;
    panel.querySelector("#close").onclick = ()=>modal.remove();

    const body = panel.querySelector("#body");
    body.appendChild(form.el);

    const btns = document.createElement("div");
    btns.className="split";
    btns.style.marginTop="10px";
    btns.innerHTML = `
      <button class="btn primary" id="save">Save</button>
      <button class="btn" id="raw">Show Raw Row</button>
    `;
    body.appendChild(btns);

    btns.querySelector("#raw").onclick = ()=>toast("warn","Raw row", JSON.stringify(row,null,2));

    btns.querySelector("#save").onclick = async ()=>{
      try{
        if(!store.token) throw new Error("Not authenticated.");
        const v = form.validate();
        if(!v.ok) throw new Error(v.errors.join("\n"));

        const payload = form.getValue();
        let path = opUpdate.path;

        const pathParams = extractPathParams(path);
        if(pathParams.length){
          const key = pathParams[0];
          path = path.replace(`{${key}}`, encodeURIComponent(String(id)));
        }

        const data = await apiFetch(path, { method: opUpdate.method, body: payload });
        toast("ok", `${label} updated`, JSON.stringify(data,null,2));
        modal.remove();
        await refreshList();
      }catch(e){
        toast("danger", `Update ${label} failed`, `${e.message}\n\n${e.data ? JSON.stringify(e.data,null,2) : ""}`.trim());
      }
    };

    modal.appendChild(panel);
    document.body.appendChild(modal);
  }

  function prefill(root, obj){
    root.querySelectorAll("input, select, textarea").forEach(inp=>{
      const id = inp.id || "";
      const m = id.match(/^f_(.+?)_/);
      if(!m) return;
      const key = m[1];
      const val = obj[key];
      if(val===undefined) return;

      if(inp.tagName==="TEXTAREA"){
        inp.value = (typeof val === "object") ? JSON.stringify(val,null,2) : String(val);
        return;
      }
      if(inp.tagName==="SELECT"){
        inp.value = String(val);
        return;
      }
      inp.value = String(val);
    });
  }

  function extractPathParams(path){
    const out = [];
    const re = /\{([^}]+)\}/g;
    let m;
    while((m=re.exec(path))) out.push(m[1]);
    return out;
  }

  refreshList();
}

function renderDebug(){
  const host = el("page");
  const box = document.createElement("div");
  box.className = "grid";

  const ops = document.createElement("div");
  ops.className = "card";
  ops.innerHTML = `
    <div class="hd"><h3>Detected Operations</h3><span class="muted">Best-effort mapping</span></div>
    <div class="bd">
      <table>
        <thead><tr><th>Key</th><th>Endpoint</th></tr></thead>
        <tbody>
          ${Object.entries(store.ops).map(([k,v])=>`
            <tr><td class="mono">${escapeHtml(k)}</td><td class="mono">${escapeHtml(opToText(v))}</td></tr>
          `).join("")}
        </tbody>
      </table>
      <div class="hint">لو me مش متكشف، هتستخدم JWT fallback. لو userById متكشف، هيتجرب بعد الـJWT.</div>
    </div>
  `;
  box.appendChild(ops);

  const who = document.createElement("div");
  who.className = "card";
  who.innerHTML = `
    <div class="hd"><h3>WhoAmI Fix</h3><span class="muted">Normalize userId</span></div>
    <div class="bd grid">
      <button class="btn primary" id="btnWho">WhoAmI (try /me then JWT then /users/{id})</button>
      <div class="muted">Current detected me: <span class="mono">${escapeHtml(opToText(store.ops.me))}</span></div>
      <div class="muted">Current detected userById: <span class="mono">${escapeHtml(opToText(store.ops.userById))}</span></div>
      <textarea id="whoResp" readonly></textarea>
    </div>
  `;
  box.appendChild(who);

  const raw = document.createElement("div");
  raw.className = "card";
  raw.innerHTML = `
    <div class="hd"><h3>Raw Call</h3><span class="muted">Manual request to any path</span></div>
    <div class="bd grid">
      <div class="split">
        <div>
          <label>Method</label>
          <select id="m">
            <option>GET</option><option>POST</option><option>PUT</option><option>PATCH</option><option>DELETE</option>
          </select>
        </div>
        <div>
          <label>Path (starts with /)</label>
          <input id="p" placeholder="/api/..." value="/" />
        </div>
      </div>
      <div class="split">
        <div>
          <label>Query (JSON object)</label>
          <textarea id="q" placeholder='{"page":0,"size":10}'></textarea>
        </div>
        <div>
          <label>Body (JSON object)</label>
          <textarea id="b" placeholder='{"key":"value"}'></textarea>
        </div>
      </div>
      <button class="btn primary" id="send">Send</button>
      <div>
        <label>Response</label>
        <textarea id="r" readonly></textarea>
      </div>
    </div>
  `;
  box.appendChild(raw);

  host.appendChild(box);

  who.querySelector("#btnWho").onclick = async ()=>{
    try{
      if(!store.token) throw new Error("Not authenticated.");
      const u = await refreshMeSmart();
      who.querySelector("#whoResp").value = JSON.stringify(u, null, 2);
      toast("ok","WhoAmI OK", `userId=${getUserId()}`);
    }catch(e){
      who.querySelector("#whoResp").value = `${e.message}\n\n${e.data ? JSON.stringify(e.data,null,2) : ""}`.trim();
      toast("danger","WhoAmI failed", e.message);
    }
  };

  raw.querySelector("#send").onclick = async ()=>{
    try{
      const method = raw.querySelector("#m").value;
      const path = raw.querySelector("#p").value.trim();
      const qtxt = raw.querySelector("#q").value.trim();
      const btxt = raw.querySelector("#b").value.trim();

      const query = qtxt ? JSON.parse(qtxt) : null;
      const body = btxt ? JSON.parse(btxt) : null;

      const data = await apiFetch(path, { method, query, body });
      raw.querySelector("#r").value = JSON.stringify(data,null,2);
      toast("ok","Request success", `${method} ${path}`);
    }catch(e){
      raw.querySelector("#r").value = `${e.message}\n\n${e.data ? JSON.stringify(e.data,null,2) : ""}`.trim();
      toast("danger","Request failed", e.message);
    }
  };
}

/* =========================
   TOPBAR ACTIONS
   ========================= */
el("btnReloadSpec").onclick = async ()=>{
  try{
    setBusy(true);
    await loadSpec();
    toast("ok","Spec reloaded", store.specUrl || "not found");
    goto(currentPage);
  }catch(e){
    toast("danger","Reload failed", e.message);
  }finally{
    setBusy(false);
  }
};

el("btnLogout").onclick = ()=>{
  store.token = "";
  store.user = null;
  localStorage.removeItem("jp_token");
  localStorage.removeItem("jp_user");
  setAuthUI();
  toast("warn","Logged out","");
  goto("login");
};

el("btnOpenSwagger").onclick = ()=>{
  window.open(CONFIG.swaggerUi, "_blank");
};

el("btnCopyToken").onclick = async ()=>{
  try{
    await navigator.clipboard.writeText(store.token || "");
    toast("ok","Copied","Token copied to clipboard.");
  }catch{
    toast("danger","Copy failed","Browser blocked clipboard.");
  }
};

el("btnClearUser").onclick = ()=>{
  store.user = null;
  localStorage.removeItem("jp_user");
  setAuthUI();
  toast("warn","User cleared","Local user removed.");
};

/* =========================
   BOOT
   ========================= */
(async function init(){
  setAuthUI();
  renderNav();
  setBusy(true);
  try{
    await loadSpec();

    // لو فيه token، ظبط userId فوراً
    if(store.token){
      await refreshMeSmart();
    }

    goto(store.token ? "courses" : "login");
  }finally{
    setBusy(false);
  }
})();
</script>
</body>
</html>
















